// These tests were generated by AI.

import { HttpClient } from "../../http/http-client";
import { toQueryString } from "../../utils/query-string.js";

jest.mock("../../utils/query-string.js", () => ({
  toQueryString: jest.fn(() => "foo=bar"),
}));

describe("HttpClient", () => {
  const baseUrl = "https://api.example.com";
  const token = "test-token";
  let client: HttpClient;
  let fetchMock: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();
    client = new HttpClient(baseUrl, token);

    fetchMock = jest.fn();
    (global as any).fetch = fetchMock;
  });

  it("should build the correct URL without query params", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve("{}"),
    });

    await client.request("GET", "/test");

    expect(fetchMock).toHaveBeenCalledWith(
      "https://api.example.com/test",
      expect.any(Object),
    );
  });

  it("should append query params to the URL", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve("{}"),
    });

    await client.request("GET", "/test", undefined, { foo: "bar" });

    expect(toQueryString).toHaveBeenCalledWith({ foo: "bar" });
    expect(fetchMock).toHaveBeenCalledWith(
      "https://api.example.com/test?foo=bar",
      expect.any(Object),
    );
  });

  it("should send request with correct headers and method", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve("{}"),
    });

    await client.request("POST", "/items", { name: "Item" });

    expect(fetchMock).toHaveBeenCalledWith(
      expect.any(String),
      expect.objectContaining({
        method: "POST",
        headers: {
          "X-SPOD-ACCESS-TOKEN": token,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ name: "Item" }),
      }),
    );
  });

  it("should not include body if not provided", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve("{}"),
    });

    await client.request("GET", "/no-body");

    expect(fetchMock).toHaveBeenCalledWith(
      expect.any(String),
      expect.not.objectContaining({ body: expect.any(String) }),
    );
  });

  it("should parse valid JSON response", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve('{"message":"ok"}'),
    });

    const res = await client.request<{ message: string }>("GET", "/json");

    expect(res.data).toEqual({ message: "ok" });
    expect(res.rawBody).toBe('{"message":"ok"}');
  });

  it("should handle empty response body", async () => {
    fetchMock.mockResolvedValue({
      status: 204,
      text: () => Promise.resolve(""),
    });

    const res = await client.request("GET", "/empty");

    expect(res.data).toBeUndefined();
    expect(res.rawBody).toBe("");
  });

  it("should handle invalid JSON response gracefully", async () => {
    fetchMock.mockResolvedValue({
      status: 200,
      text: () => Promise.resolve("invalid-json"),
    });

    const res = await client.request("GET", "/invalid");

    expect(res.data).toBeUndefined();
    expect(res.rawBody).toBe("invalid-json");
  });
});
